package  com.hdi.animation.plugins{	import flash.geom.ColorTransform;	import com.hdi.animation.MoveThisObject;			public class MoveColor {				//-------------------------------		// required functions		//-------------------------------				/**		 * @required name plugin function		 * main tweening function		 * 		 * @params moveObj, and instance of MoveThisObject which contains all the settings for the tween		 * @params easingFunction, allows this pluging to use any standard easing functions		 * 		 */		public static function color(moveObj:MoveThisObject,easingFunction:Function = null):void{			//convert colors to channels			var startColors:Object = colorChannels(moveObj.startValue);			var finColors:Object = colorChannels(moveObj.finValue);			var transColors:Object = {r:finColors.r-startColors.r,g:finColors.g-startColors.g,b:finColors.b-startColors.b};						//animation color channels linearly			var rchan:int;			var gchan:int;			var bchan:int;						var rchanLinear:int = transColors.r*((moveObj.currentFrame/moveObj.frames)*(1-moveObj.easingStrength)) + startColors.r;			var gchanLinear:int = transColors.g*((moveObj.currentFrame/moveObj.frames)*(1-moveObj.easingStrength)) + startColors.g;			var bchanLinear:int = transColors.b*((moveObj.currentFrame/moveObj.frames)*(1-moveObj.easingStrength)) + startColors.b;						//animate color channels based on easing function			if(easingFunction != null){				rchan = easingFunction(moveObj.currentFrame, startColors.r, transColors.r, moveObj.frames);				gchan = easingFunction(moveObj.currentFrame, startColors.g, transColors.g, moveObj.frames);				bchan = easingFunction(moveObj.currentFrame, startColors.b, transColors.b, moveObj.frames);								//apply easing strength				if(moveObj.easingStrength != 1){					rchan = (rchan*moveObj.easingStrength) + rchanLinear;					gchan = (gchan*moveObj.easingStrength) + gchanLinear;					bchan = (bchan*moveObj.easingStrength) + bchanLinear;				}			}			else{				//linear				rchan = rchanLinear;				gchan = gchanLinear;				bchan = bchanLinear;			}												//apply new tweened value to object			var colorobj:Object = {r:rchan,g:gchan,b:bchan};			var color:int = channelsToColor(colorobj);						var trans:ColorTransform = new ColorTransform();			trans.color = color;			moveObj.targetObj.transform.colorTransform = trans;				}				/**		 * @required startValue		 * get the starting property value		 * 		 * @param obj, the object whos property is being animated		 * @param prop, the property name of property or plugin function - brightness		 * 		 * @default 0;		 */		public static function startValue(obj:Object,prop:String):Number{			// get the current color			var trans:ColorTransform = obj.transform.colorTransform;			return trans.color;		}				/**		 * @required resetValue		 * set the tween value back to the starting value, for looping tweens		 * 		 * @param moveObj, instance of MoveThisObject containing all the tween settings		 */		public static function resetValue(moveObj:MoveThisObject):void{			//reset the color to the starting color			var trans:ColorTransform = new ColorTransform();			trans.color = moveObj.startValue;			moveObj.targetObj.transform.colorTransform = trans;		}				//------------------------------------------		// plugin specific functions		//-----------------------------------------				/**		 * 		 * @private		 * 		 * adjust color channels based on input		 */		private static function colorChannels(color:int):Object{			var red:int = ((color & 0xFF0000) >>16);			var green:int = ((color & 0x00FF00) >>8);			var blue:int = ((color & 0x0000FF));			return {r:red,g:green,b:blue};		}				/**		 * @private		 * 		 * convert rgb to hex color		 */		private static function channelsToColor(obj:Object):int{			return ( obj.r << 16 ) + ( obj.g << 8 ) + obj.b;		}		public function MoveColor() {			// constructor code		}	}	}